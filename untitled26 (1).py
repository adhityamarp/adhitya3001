# -*- coding: utf-8 -*-
"""Untitled26.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZoE7W78RcEJi_giDLCy7ovJAkienVL5R
"""

!pip install PyPDF2
!pip install python-docx

import PyPDF2
from docx import Document
import re
import spacy
import random
from spacy.lang.en.stop_words import STOP_WORDS

nlp = spacy.load("en_core_web_lg")

def extract_keywords(text):
    """Extract significant nouns, proper nouns, and other key terms from the text."""
    doc = nlp(text)
    keywords = [token.text for token in doc if token.pos_ in ("NOUN", "PROPN") and len(token.text) > 2]
    return list(set(keywords))  # Remove duplicates

def generate_distractors(correct_answer, keywords):
    """Generate distractors that are semantically related to the correct answer."""
    distractors = [word for word in keywords if word.lower() != correct_answer.lower()]
    random.shuffle(distractors)
    return distractors[:3]  # Return the top 3 distractors

def clean_entity(entity_text):
    """Removes special characters and unnecessary prefixes/suffixes from entity text."""
    cleaned_text = re.sub(r"[^\w\s]", "", entity_text)  # Remove special characters
    cleaned_text = cleaned_text.strip()  # Remove leading/trailing whitespace
    return cleaned_text

def generate_mcq_dynamic(text):
    """Generate MCQs with enhanced logic and various question types."""
    doc = nlp(text)
    questions = []

    for sentence in doc.sents:
        # Entity-centric question example (original format - role_in_context)
        for ent in sentence.ents:
            if ent.label_ in ["PERSON", "ORG", "GPE"]:
                cleaned_entity = clean_entity(ent.text)
                question = f"What is the role of {cleaned_entity} in this context?"
                distractors = generate_distractors(cleaned_entity, [token.text for token in sentence if token.pos_ in ["NOUN", "PROPN"]])
                questions.append({
                    "question": question,
                    "correct_answer": cleaned_entity,
                    "options": [cleaned_entity] + distractors,
                    "context": sentence.text,
                    "question_type": "role_in_context"
                })

        # Multiple Choice with Context (multiple_choice_context)
        for ent in sentence.ents:
            if ent.label_ in ["PERSON", "ORG", "GPE"]:
                cleaned_entity = clean_entity(ent.text)
                question = f"According to the context, which of the following is true about {cleaned_entity}?"
                distractors = generate_distractors(cleaned_entity, [token.text for token in sentence if token.pos_ in ["NOUN", "PROPN"]])
                questions.append({
                    "question": question,
                    "correct_answer": cleaned_entity,  # Assuming the entity itself is the correct answer
                    "options": [cleaned_entity] + distractors,
                    "context": sentence.text,
                    "question_type": "multiple_choice_context"
                })

        # True/False (true_false)
        for ent in sentence.ents:
            if ent.label_ in ["PERSON", "ORG", "GPE"]:
                cleaned_entity = clean_entity(ent.text)
                statement = f"{cleaned_entity} is mentioned in the context."  # Example statement
                is_true = cleaned_entity in sentence.text  # Check if the statement is true
                questions.append({
                    "question": statement,
                    "correct_answer": str(is_true),  # Convert boolean to string
                    "options": ["True", "False"],
                    "context": sentence.text,
                    "question_type": "true_false"
                })

        # Fill-in-the-Blanks (fill_in_the_blanks)
        for ent in sentence.ents:
            if ent.label_ in ["PERSON", "ORG", "GPE"]:
                cleaned_entity = clean_entity(ent.text)
                question = sentence.text.replace(cleaned_entity, "_______")  # Replace entity with blank
                questions.append({
                    "question": question,
                    "correct_answer": cleaned_entity,
                    "options": [],  # No options needed for fill-in-the-blanks
                    "context": sentence.text,
                    "question_type": "fill_in_the_blanks"
                })

        # Open-Ended (open_ended)
        for ent in sentence.ents:
            if ent.label_ in ["PERSON", "ORG", "GPE"]:
                cleaned_entity = clean_entity(ent.text)
                question = f"Explain the concept of {cleaned_entity} in your own words."
                questions.append({
                    "question": question,
                    "correct_answer": "",  # No predefined correct answer for open-ended
                    "options": [],  # No options needed for open-ended
                    "context": sentence.text,
                    "question_type": "open_ended"
                })

    return questions

def display_questions_dynamic(questions, num_questions):
    """Display a limited number of questions with dynamic options."""
    selected_questions = random.sample(questions, min(num_questions, len(questions)))
    score = 0

    for i, q in enumerate(selected_questions, 1):
        print(f"Q{i}: {q['question']}")
        options = random.sample(q['options'], len(q['options']))  # Shuffle options
        for j, option in enumerate(options, 1):
            print(f"   {j}. {option}")
        try:
            answer = int(input("Your answer (enter option number): "))
            if options[answer - 1] == q['correct_answer']:
                score += 1
                print("Correct!")
            else:
                print(f"Incorrect. The correct answer is: {q['correct_answer']}")
        except (ValueError, IndexError):
            print("Invalid input! Moving to the next question.")
    return score, len(selected_questions)

def extract_text_from_docx(file_path):
    """Extracts text from a DOCX file using python-docx."""
    doc = Document(file_path)
    text = ""
    for paragraph in doc.paragraphs:
        text += paragraph.text + "\n"
    return text

if __name__ == "__main__":
    file_path = input("Enter the path to your PDF or DOCX file: ")  # Get input from the user

    # Extract text based on file type
    if file_path.endswith(".pdf"):
        text = extract_text_from_pdf(file_path) # Assigning the result to text variable
    elif file_path.endswith(".docx"):
        text = extract_text_from_docx(file_path) # Assigning the result to text variable
    else:
        print("Unsupported file type! Please provide a PDF or DOCX file.")
        exit()

    # Generate MCQs with dynamic options
    questions = generate_mcq_dynamic(text)
    print(f"{len(questions)} questions generated.")

    # Allow user to select the number of questions
    num_questions = int(input("Enter the number of questions you want to attempt: ")) # Get input for num_questions
    score, total = display_questions_dynamic(questions, num_questions)
    print(f"You scored {score}/{total}")

